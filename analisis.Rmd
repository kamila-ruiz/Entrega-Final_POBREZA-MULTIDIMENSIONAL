---
title: "analisis????"
author: "kamila"
date: "2025-06-29"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(stringi)
library(flexdashboard)
library(ggplot2)
library(dplyr)
library(ggthemes)
library(kableExtra)
library(plotly)
library(fontawesome)
library(rio)
library(DT)
library(vtable)
library(reshape2) 
library(tmap)
library(tidyverse)
library(modelsummary)
library(sf) 
```

```{r}
setwd("D:\\2025-1\\Est 2\\datas trabajo final")
```

```{r}
enaho=import("enaho1.csv")
```
volver a factor
```{r}
enaho=enaho%>%
  mutate(POBREZA = factor(POBREZA, levels = c(0:1)))

enaho=enaho%>%
  mutate(INTERNET = factor(INTERNET, levels = c(0:1)))

enaho=enaho%>%
  mutate(NIVEL_EDU = factor(NIVEL_EDU, levels=c(1:7),ordered=TRUE))

enaho=enaho%>%
  mutate(MAL_CRONICO = factor(MAL_CRONICO, levels = c(0:1)))

enaho=enaho%>%
  mutate(TIPO_EMPLEO = factor(TIPO_EMPLEO, levels = c(0:1)))
```

hacer departamentos
```{r}
enaho$UBIGEO = stringr::str_pad(enaho$UBIGEO, width=6, side="left", pad="0")
enaho$UBIGEO=substr(enaho$UBIGEO,1,2)
enaho=enaho%>%
  mutate(DEPARTAMENTO=case_when(
    UBIGEO == "01" ~ "AMAZONAS",
    UBIGEO == "02" ~ "ANCASH",
    UBIGEO == "03" ~ "APURIMAC",
    UBIGEO == "04" ~ "AREQUIPA",
    UBIGEO == "05" ~ "AYACUCHO",
    UBIGEO == "06" ~ "CAJAMARCA",
    UBIGEO == "07" ~ "CALLAO",
    UBIGEO == "08" ~ "CUSCO",
    UBIGEO == "09" ~ "HUANCAVELICA",
    UBIGEO == "10" ~ "HUANUCO",
    UBIGEO == "11" ~ "ICA",
    UBIGEO == "12" ~ "JUNIN",
    UBIGEO == "13" ~ "LA LIBERTAD",
    UBIGEO == "14" ~ "LAMBAYEQUE",
    UBIGEO == "15" ~ "LIMA",
    UBIGEO == "16" ~ "LORETO",
    UBIGEO == "17" ~ "MADRE DE DIOS",
    UBIGEO == "18" ~ "MOQUEGUA",
    UBIGEO == "19" ~ "PASCO",
    UBIGEO == "20" ~ "PIURA",
    UBIGEO == "21" ~ "PUNO",
    UBIGEO == "22" ~ "SAN MARTIN",
    UBIGEO == "23" ~ "TACNA",
    UBIGEO == "24" ~ "TUMBES",
    UBIGEO == "25" ~ "UCAYALI"))
```
eliminar fila ubigeo
```{r}
enaho=enaho[,-c(6)]
```
============
PROBLEMÁTICA OBSERVADA
Si bien en el país se han implementado diversas estrategias para combatir la pobreza a lo largo de los años, aún es un problema pendiente para la agenda estatal. Gran parte de estas políticas públicas han abordado esta compleja problemática socioeconómica bajo el enfoque monetario absoluto y objetivo que emplea actualmente el Instituto Nacional de Estadística e Informática (INEI) sobre la pobreza a nivel nacional

Pese a que el Decreto Supremo 014-2024-MIDIS establece la implementación de la primera medición de pobreza multidimensional en complemento de la medición actual de pobreza monetaria, hasta el momento solo existe una versión preliminar del documento titulado “Pobreza Multidimensional - Avance (Revisión 2025)”. 

PREGUNTA DE INVESTIGACIÓN

¿Que factores no económicos influyen en la condición de pobreza en los hogares peruanos en 2022?

JUSTIFICACIÓN

Durante décadas, la respuesta del Estado peruano ha sido condicionada a una carencia en la forma de evaluar la pobreza en el país. Se identifica un vacío en la medición de pobreza a nivel nacional, puesto que la metodología vigente subestima la condición de pobreza real en contextos donde factores estructurales limitan e impiden que muchos hogares aún no superen el umbral de gasto, por ello, resulta pertinente analizar el fenómeno de la pobreza y sus determinantes en términos más allá de los monetarios, es decir desde un enfoque multidimensional.

HIPOTESIS ANIDADAS

H1: La condicion de pobreza del hogar puede predecirse a partir del acceso a internet dentro de la misma

H2: La condición de pobreza del hogar ese predice en tanto se considera el acceso a internet del mismo como el nivel educativo alcanzado predominante entre los miembros.

H3: La condicion de pobreza del hogar es condicionada al acceso a internet, al nivel educativo alcanzado predominante entre los mimebros y el padecimiento de enfermedades o males crónicos como aspecto prevalente dentro de la unidad doméstica

H4: La condicion de pobreza de la unidad doméstica se puede predecir a aprtir del acceso a internet, el nivel educativo alcanzado predominante, al padeciiento de enfermades o males cronicos como condicion prevalente y al tipo de empleo más frecuente dentro del hogar 

--> La presente investigación se basa en la hipotesis de que los factores no economicos como el acceso a internet, el nivel de educacion alcanzado más representativo por los miembros del hogar, padecimiento de alguna enfermedad o mal cronico como condicion predominante y el tipo de empleo modal de a unidad doméstica inciden sobre la condicion de pobreza de la misma.


METODOLOGÍA
El presente trabajo emplea la base de datos llamada "Enaho" o Encuesta Nacional de Hogares, en tal sentido se entiende que esta ivestigacion se basa en un diseño de metodo no experimental en tanto se escogió la base de datos proveniente a Enaho. Se considera que dicha base aborda de modo completo los diferntes factores no monetarios que influyen en el desarrollo de vida del sujeto y caracterizan a su hogar. La base de datos en cuestion recopila las respuestas de una muestra total de 36848 viviendas particulares del año 2022 a nivel nacional. Asimismo, al momento de revisar cada base de datos de cada modulo o seccion por tematica que aborda la encuesta, se encontró que en realidad el total muestral del Enaho 2022 fue de 34213, lo cual nos da una idea de que la tasa de no respuesta influye en la cantidad de viviendas totales encuestadas y por tanto en la precision de los resultados de la encuesta.

============
analisis descriptivo
INTERNET
```{r}
tabla_internet=enaho%>%
  count(INTERNET = INTERNET,name="Frecuencia")%>%
  mutate(Porcentaje = (Frecuencia/sum(Frecuencia)*100))%>%
  mutate(INTERNET = case_when(
    INTERNET == 1 ~ "Si", 
    INTERNET == 0 ~ "No"))
tabla_internet
```
por departamento
```{r}
tabla_internet_dep=enaho%>%
  group_by(DEPARTAMENTO)%>%
  count(INTERNET = INTERNET,name="Frecuencia")%>%
  mutate(Porcentaje = (round(Frecuencia/sum(Frecuencia)*100,1)))
tabla_internet_dep
```
grafico de barras
```{r}
grafico_inter =	ggplot(tabla_internet,aes(x=reorder(INTERNET,-Porcentaje), y=Porcentaje, fill=INTERNET)) + 
ggtitle("Porcentaje de hogares que cuenta con Internet a nivel nacional")+ 
  		geom_bar(stat ="identity") + 
xlab("Tiene o no conexión a Internet") + ylab("Porcentaje") +
geom_text(aes(label=round(Porcentaje,1)), vjust=0, color="black", size=3)+
scale_fill_brewer(name="Tiene o no conexión a Internet", palette="Pastel1")
grafico_inter
```
1 = si cuenta con internet
0 = No cuenta con internet

ahora con NIVEL DE EDUCACION
```{r}
tabla_edu=enaho%>%
  count(NIVEL_EDU = NIVEL_EDU,name="Frecuencia")%>%
  mutate(Porcentaje = (round(Frecuencia/sum(Frecuencia)*100,1)))%>%
  mutate(NIVEL_EDU = case_when(
    NIVEL_EDU == 1 ~ "Sin nivel educativo", 
    NIVEL_EDU == 2 ~ "Educacion inicial",
    NIVEL_EDU == 3 ~ "Educacion primaria",
    NIVEL_EDU == 4 ~ "Educacion secundaria",
    NIVEL_EDU == 5 ~ "Superior no universitaria",
    NIVEL_EDU == 6 ~ "Superior universitaria",
    NIVEL_EDU == 7 ~ "Educación básica especial",
    ))
tabla_edu
```
EDU por departamento
```{r}
tabla_edu_dep=enaho%>%
  group_by(DEPARTAMENTO)%>%
  count(NIVEL_EDU = NIVEL_EDU,name="Frecuencia")%>%
  mutate(Porcentaje = (round(Frecuencia/sum(Frecuencia)*100,1)))
tabla_edu_dep
```
grafico de barras
```{r}
grafico_edu =	ggplot(tabla_edu,aes(x=reorder(NIVEL_EDU,-Porcentaje), y=Porcentaje, fill=NIVEL_EDU)) + 
ggtitle("Porcentaje de hogares que cuenta con Internet a nivel nacional")+ 
  		geom_bar(stat ="identity") + 
xlab("Nivel de educacion alcanzado") + ylab("Porcentaje") +
geom_text(aes(label=round(Porcentaje,1)), vjust=0, color="black", size=3)+
scale_fill_brewer(name="Nivel de educacion alcanzado", palette="Pastel2")
grafico_edu
```
1= Sin nivel educativo
2= Educación Inicial
3= Educación Primaria 
4= Educación Secundaria
5= Educación superior no universitaria
6= Educación superior universitaria
7= Educación Básica Especial

ahora con padecimiento o no de MAL CRONICO
```{r}
tabla_mal=enaho%>%
  count(MAL_CRONICO = MAL_CRONICO,name="Frecuencia")%>%
  mutate(Porcentaje = (round(Frecuencia/sum(Frecuencia)*100,1)))%>%
  mutate(MAL_CRONICO = case_when(
    MAL_CRONICO == 1 ~ "Si", 
    MAL_CRONICO == 0 ~ "No"))
tabla_mal
```
MAL CRONICO por departamento
```{r}
tabla_mal_dep=enaho%>%
  group_by(DEPARTAMENTO)%>%
  count(MAL_CRONICO = MAL_CRONICO,name="Frecuencia")%>%
  mutate(Porcentaje = (round(Frecuencia/sum(Frecuencia)*100,1)))
tabla_mal_dep
```
grafico de barras
```{r}
grafico_mal =	ggplot(tabla_mal,aes(x=reorder(MAL_CRONICO,-Porcentaje), y=Porcentaje, fill=MAL_CRONICO)) + 
ggtitle("Porcentaje de hogares con alguna enfermedad o malestar crónico")+ 
  		geom_bar(stat ="identity") + 
xlab("Padece o no padece") + ylab("Porcentaje") +
geom_text(aes(label=round(Porcentaje,1)), vjust=0, color="black", size=3)+
scale_fill_brewer(name="Padece o no padece", palette="Pastel2")
grafico_mal
```
1 = Padece
0 = No padece

ahora con TIPO DE EMPLEO
```{r}
tabla_empleo=enaho%>%
  count(TIPO_EMPLEO = TIPO_EMPLEO,name="Frecuencia")%>%
  mutate(Porcentaje = (round(Frecuencia/sum(Frecuencia)*100,1)))%>%
  mutate(TIPO_EMPLEO = case_when(
    TIPO_EMPLEO == 1 ~ "Empleo Formal", 
    TIPO_EMPLEO == 0 ~ "Empleo Informal"))
tabla_empleo
```
TIPO EMPLEO por departamento
```{r}
tabla_empleo_dep=enaho%>%
  group_by(DEPARTAMENTO)%>%
  count(TIPO_EMPLEO = TIPO_EMPLEO,name="Frecuencia")%>%
  mutate(Porcentaje = (round(Frecuencia/sum(Frecuencia)*100,1)))
tabla_empleo_dep
```
grafico de barras
```{r}
grafico_empleo =	ggplot(tabla_empleo,aes(x=reorder(TIPO_EMPLEO,-Porcentaje), y=Porcentaje, fill=TIPO_EMPLEO)) + 
ggtitle("Porcentaje de hogares según tipo de empleo")+ 
  		geom_bar(stat ="identity") + 
xlab("Tipo de empleo") + ylab("Porcentaje") +
geom_text(aes(label=round(Porcentaje,1)), vjust=0, color="black", size=3)+
scale_fill_brewer(name="Tipo de empleo", palette="Pastel4")
grafico_empleo
```

1= Empleo Formal
0= Empleo Informal

hacer lo mismo para variable POBREZA
```{r}
tabla_pobre=enaho%>%
  count(POBREZA = POBREZA,name="Frecuencia")%>%
  mutate(Porcentaje = (round(Frecuencia/sum(Frecuencia)*100,1)))%>%
  mutate(POBREZA = case_when(
    POBREZA == 1 ~ "Pobreza", 
    POBREZA == 0 ~ "No pobreza"))
tabla_pobre
```
POBREZA por departamento
```{r}
tabla_pobre_dep=enaho%>%
  group_by(DEPARTAMENTO)%>%
  count(POBREZA = POBREZA,name="Frecuencia")%>%
  mutate(Porcentaje = (round(Frecuencia/sum(Frecuencia)*100,1)))
tabla_pobre_dep
```
grafico de barras
```{r}
grafico_pobre =	ggplot(tabla_pobre,aes(x=reorder(POBREZA,-Porcentaje), y=Porcentaje, fill=POBREZA)) + 
ggtitle("Porcentaje de hogares en condicion de pobreza y no pobreza a nivel nacional")+ 
  		geom_bar(stat ="identity") + 
xlab("Pobreza o no pobreza") + ylab("Porcentaje") +
geom_text(aes(label=round(Porcentaje,1)), vjust=0, color="black", size=3)+
scale_fill_manual(name="Pobreza o no pobreza", values = c("No pobreza" = "#d1a1e2", "Pobreza" = "#80e0d3"))
grafico_pobre
```
1= Pobreza = agrupa pobreza  y pobreza extrema
0= No pobreza

para hacer grafico pie sobre pobreza a nivel nacional por hogares
```{r}
library(plotly)
pobreza_pie <- data.frame(
  POBREZA = c("No Pobreza","Pobreza"),
  Frecuencia = c(27192, 7021),
  Porcentaje = c(79.5, 20.5)
)

#grafico
pie_pobreza <- plot_ly(data = pobreza_pie,
               labels = ~POBREZA,
               values = ~Frecuencia,
               type = 'pie',
               textinfo = 'none',
               hoverinfo = 'label+percent+value',
               marker = list(colors = c('#d1a1e2', '#80e0d3')))%>%
    layout(title = "Distribución de hogares según condición de pobreza",
         showlegend = TRUE)
pie_pobreza
```
paleta de colores
"#D1A1E2", # Lavanda claro
  "#EEC1B1", # Rosa pastel
  "#80E0D3", # Aqua pastel
  "#F3B7D0", # Rosa suave
  "#D6E8A1", # Verde pastel
  "#F8D2B5", # Melocotón suave
  "#A1D9E8", # Azul claro pastel
  "#F2C6A0", # Amarillo pastel
  "#D2E2D9", # Verde agua suave

contar Nas = no hay Nas
========================
Pruebas estadísticas: CHI2 por cada variable independiente

hipótesis nula (H0): no hay asociación estadística entre las variables
hipótesis alternativa (H1): si hay asociación estadística entre las variables 

chi2: pobreza e internet

primero tabla de contingencia y luego su visulizacion bonita
```{r}
library(knitr)
library(kableExtra)
```

crear tabla con frecuencias cruzadas y su matriz manualmente
```{r}
tabla_contingencia1 <- table(enaho$POBREZA, enaho$INTERNET) #filas = pobreza, col = internet
tabla_contingencia1
```
--> NO POBREZA = 11 498 hogares no tienen internet y 15 694 si tienen internet
--> POBREZA = 5363 hogares no tienen internet y 1658 si tienen internet
```{r}
#cambiar nombres
dimnames(tabla_contingencia1) <- list(
  POBREZA = c("No pobreza", "Pobreza"),
  INTERNET = c("No tiene", "Si tiene")
)

#matriz con nombres
tablachi1 <- matrix(c(11498, 15694, 5363, 1658), nrow = 2, byrow = TRUE,
                   dimnames = list("POBREZA" = c("No pobreza", "Pobreza"),
                                   "INTERNET" = c("No tiene", "Si tiene")))
tablachi1
```
1 = si cuenta con internet
0 = No cuenta con internet

visualizar tabla con frecuencias cruzadas de forma bonita
```{r}
df_tablachi1 <- as.data.frame(tablachi1)
df_tablachi1$POBREZA <- rownames(df_tablachi1)
df_tablachi1 <- df_tablachi1[, c("POBREZA", "No tiene", "Si tiene")]

# Visualización 
library(knitr)
library(kableExtra)
library(dplyr)

df_tablachi1 %>%
  kable(caption = "Tabla de Contingencia: Pobreza y Acceso a Internet") %>%
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE, position = "center", font_size = 14) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, color = "Black", background = "#D7A7D1") %>%
  column_spec(2:3, width = "6em")

```
prueba chi2
```{r}
resultadochi1 <- chisq.test(tablachi1)
```
visulizar resultados chi2
```{r}
# tabla resumen
vis_chi1 <- data.frame(
  Estimación = c("Estadística Chi-cuadrado", "Valor p"),
  Valor = c(as.numeric(resultadochi1$statistic),as.numeric(resultadochi1$p.value))
)

#ver pvalue pequeño
vis_chi1$Valor <- ifelse(vis_chi1$Estimación == "Valor p" & vis_chi1$Valor < 0.001,
                        "< 0.001",
                        round(vis_chi1$Valor, 3))

#para verlo bonito
vis_chi1 %>%
  kable(caption = "Chi cuadrado: Pobreza y acceso a Internet") %>%
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE, position = "center") %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, color = "Black", background = "#D7A7D1")

```
INTERPRETACION: dado que el pvalue es menor a 0.05 = se rechaza H0 = existe asociacion estadísticamente significativa entre la condicion de pobreza y el acceso a internet 

tabla porcentajes para grafico bivariado: pobreza e internet
```{r}
tabla_porcentaje1= as.data.frame(tabla_contingencia1%>%
  prop.table(1) %>%
  round(3)*100)
tabla_porcentaje1
```
grafico porcentajes bivariado: pobreza e internet
```{r}
graf_bivariado1= ggplot(data=tabla_porcentaje1, aes(x=POBREZA, y=Freq, fill=INTERNET))+
  geom_bar(position="stack", stat="identity")+
  geom_text(aes(label=paste(Freq, "%", sep="")), 
            position = position_stack(), vjust=1, size = 4, color="white", fontface = "bold")+
  labs(x="Pobreza", y="Porcentaje", fill="Hogares con o sin acceso a internet",title="Distribución del acceso a Internet según condición de pobreza") +
  scale_fill_manual(values=c("No tiene"="#D7A7D1", "Si tiene"="#8F3B70")) + 
  theme_minimal()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
graf_bivariado1
```
=====
chi2 pobreza y nivel de educacion
crear tabla con frecuencias cruzadas y su matriz manualmente
```{r}
tabla_contingencia2<- table(enaho$POBREZA, enaho$NIVEL_EDU) #filas = pobreza, col = edu

#cambiar nombres
dimnames(tabla_contingencia2) <- list(
  POBREZA = c("No pobreza", "Pobreza"),
  NIVEL_EDU = c("1: Sin nivel educativo", 
                "2: Educación Inicial", 
                "3: Educación Primaria", 
                "4: Educación Secundaria", 
                "5: Superior no universitaria", 
                "6: Superior universitaria", 
                "7: Educación Básica Especial")
)

#ver orden exacto de valores para la matrix
as.vector(tabla_contingencia2)
```
matrix con nombres
```{r}
tablachi2 <- matrix(
  c(2310, 1071, 843, 256, 9252, 3409, 9686, 
    2112, 1956, 112, 3142, 60, 3, 1),
  nrow = 2, byrow = TRUE,
  dimnames = list(
    "POBREZA" = c("No pobreza", "Pobreza"),
    "NIVEL_EDU" = c(
      "1: Sin nivel educativo",
      "2: Educación Inicial",
      "3: Educación Primaria",
      "4: Educación Secundaria",
      "5: Superior no universitaria",
      "6: Superior universitaria",
      "7: Educación Básica Especial")))
tablachi2
```
visualizar tabla con frecuencias cruzadas de forma bonita
```{r}
df_tablachi2 <- as.data.frame(tablachi2)
df_tablachi2$POBREZA <- rownames(df_tablachi2)
df_tablachi2 <- df_tablachi2[, c("POBREZA", "1: Sin nivel educativo",
                               "2: Educación Inicial",
                               "3: Educación Primaria",
                               "4: Educación Secundaria",
                               "5: Superior no universitaria",
                               "6: Superior universitaria",
                               "7: Educación Básica Especial")]

# Visualización 
df_tablachi2 %>%
  kable(caption = "Tabla de Contingencia: Pobreza y Nivel educativo alcanzado") %>%
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE, position = "center", font_size = 14) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, color = "Black", background = "#F5A1A1") %>%
  column_spec(2:8, width = "6em")

```
prueba chi2
```{r}
resultadochi2 <- chisq.test(tablachi2)
```
visulizar resultados chi2
```{r}
# tabla resumen
vis_chi2 <- data.frame(
  Estimación = c("Estadística Chi-cuadrado", "Valor p"),
  Valor = c(as.numeric(resultadochi2$statistic),as.numeric(resultadochi2$p.value))
)

#ver pvalue pequeño
vis_chi2$Valor <- ifelse(vis_chi2$Estimación == "Valor p" & vis_chi2$Valor < 0.001,
                        "< 0.001",
                        round(vis_chi2$Valor, 3))

#para verlo bonito
vis_chi2 %>%
  kable(caption = "Chi cuadrado: Pobreza y Nivel educativo") %>%
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE, position = "center") %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, color = "Black", background = "#F5A1A1")

```
INTERPRETACION: dado que el pvalue es menor a 0.05 = se rechaza H0 = existe asociacion estadísticamente significativa entre la condicion de pobreza y el nivel educativo alcanzado (moda) por hogar --> la distribucion de la pobreza varia según el nivel de educacion 

tabla porcentajes para grafico bivariado: pobreza y nivel educativo
```{r}
tabla_porcentaje2= as.data.frame(tabla_contingencia2%>%
  prop.table(1) %>%
  round(3)*100)
tabla_porcentaje2
```
grafico porcentajes bivariado: pobreza e internet
```{r}
graf_bivariado2 = ggplot(data=tabla_porcentaje2, aes(x=POBREZA, y=Freq, fill=NIVEL_EDU)) +
  geom_bar(position="stack", stat="identity") +
  geom_text(aes(label=paste(Freq, "%", sep="")), 
            position = position_stack(), vjust=1, size=3, color="white",fontface="bold") +
  labs(x="Pobreza", y="Porcentaje", fill="Nivel educativo", title="Distribución del nivel educativo según condición de pobreza") +
  scale_fill_manual(values=c("#F6C1C1", "#F17A84", "#E04F6F", "#D2344D", "#9E1A2A","#871C33", "#4C1423")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle=45, hjust=1))
graf_bivariado2
```
==========
chi cuadrado: pobreza y padecimiento o no de algun mal cronico

crear tabla con frecuencias cruzadas y su matriz manualmente
```{r}
tabla_contingencia3 <- table(enaho$POBREZA, enaho$MAL_CRONICO) #filas = pobreza, col = mal cro

#cambiar nombres
dimnames(tabla_contingencia3) <- list(
  POBREZA = c("No pobreza", "Pobreza"),
  MAL_CRONICO = c("No padece", "Si padece")
)
tabla_contingencia3
```
matriz con nombres
```{r}
tablachi3 <- matrix(c(15787, 11405, 5275, 1746), nrow = 2, byrow = TRUE,
                   dimnames = list("POBREZA" = c("No pobreza", "Pobreza"),
                                   "MAL_CRONICO" = c("No padece", "Si padece")))
tablachi3
```
visualizar tabla con frecuencias cruzadas de forma bonita
```{r}
df_tablachi3 <- as.data.frame(tablachi3)
df_tablachi3$POBREZA <- rownames(df_tablachi3)
df_tablachi3 <- df_tablachi3[, c("POBREZA", "No padece", "Si padece")]

# Visualización 
df_tablachi3 %>%
  kable(caption = "Tabla de Contingencia: Pobreza y Padecimiento de mal crónico") %>%
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE, position = "center", font_size = 14) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, color = "Black", background = "#F1C2A1") %>%
  column_spec(2:3, width = "6em")

```
prueba chi2
```{r}
resultadochi3 <- chisq.test(tablachi3)
```
visulizar resultados chi2
```{r}
# tabla resumen
vis_chi3 <- data.frame(
  Estimación = c("Estadística Chi-cuadrado", "Valor p"),
  Valor = c(as.numeric(resultadochi3$statistic),as.numeric(resultadochi3$p.value))
)

#ver pvalue pequeño
vis_chi3$Valor <- ifelse(vis_chi3$Estimación == "Valor p" & vis_chi3$Valor < 0.001,
                        "< 0.001",
                        round(vis_chi3$Valor, 3))

#para verlo bonito
vis_chi3 %>%
  kable(caption = "Chi cuadrado: Pobreza y Padecimiento de mal crónico") %>%
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE, position = "center") %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, color = "Black", background = "#F1C2A1")

```
tabla porcentajes para grafico bivariado: pobreza y padecer mal cronico
```{r}
tabla_porcentaje3= as.data.frame(tabla_contingencia3%>%
  prop.table(1) %>%
  round(3)*100)
tabla_porcentaje3
```
grafico porcentajes bivariado: pobreza e internet
```{r}
graf_bivariado3= ggplot(data=tabla_porcentaje3, aes(x=POBREZA, y=Freq, fill=MAL_CRONICO))+
  geom_bar(position="stack", stat="identity")+
  geom_text(aes(label=paste(Freq, "%", sep="")), 
            position = position_stack(), vjust=1, size = 4, color="black", fontface = "bold")+
  labs(x="Pobreza", y="Porcentaje", fill="Mal crónico",title="Distribución de mal cronico según condición de pobreza") +
  scale_fill_manual(values=c("No padece"="#F1C2A1", "Si padece"= "#E86C00")) + 
  theme_minimal()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
graf_bivariado3
```
INTERPRETACION: dado que el pvalue es menor a 0.05 = se rechaza H0 = existe asociacion estadísticamente significativa entre la condicion de pobreza y el padecimiento de alguna enfermedad o mal cronico (moda)
==========
chi2: pobreza y tipo de empleo (formal 1, informal 0)
crear tabla con frecuencias cruzadas y su matriz manualmente
```{r}
tabla_contingencia4 <- table(enaho$POBREZA, enaho$TIPO_EMPLEO) #filas = pobreza, col = empleo

#cambiar nombres
dimnames(tabla_contingencia4) <- list(
  POBREZA = c("No pobreza", "Pobreza"),
  TIPO_EMPLEO = c("Empleo informal", "Empleo formal")
)
tabla_contingencia4
```
matriz con nombres
```{r}
tablachi4 <- matrix(c(17336, 9856, 5718, 1303), nrow = 2, byrow = TRUE,
                   dimnames = list("POBREZA" = c("No pobreza", "Pobreza"),
                                   "TIPO_EMPLEO" = c("Empleo informal", "Empleo formal")))
tablachi4
```
visualizar tabla con frecuencias cruzadas de forma bonita
```{r}
df_tablachi4 <- as.data.frame(tablachi4)
df_tablachi4$POBREZA <- rownames(df_tablachi4)
df_tablachi4 <- df_tablachi4[, c("POBREZA","Empleo informal", "Empleo formal")]

# Visualización 
df_tablachi4 %>%
  kable(caption = "Tabla de Contingencia: Pobreza y Tipo de empleo") %>%
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE, position = "center", font_size = 14) %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, color = "Black", background = "#D6E8A1") %>%
  column_spec(2:3, width = "6em")
```
prueba chi2
```{r}
resultadochi4 <- chisq.test(tablachi4)
```
visulizar resultados chi2
```{r}
# tabla resumen
vis_chi4 <- data.frame(
  Estimación = c("Estadística Chi-cuadrado", "Valor p"),
  Valor = c(as.numeric(resultadochi4$statistic),as.numeric(resultadochi4$p.value)))

#ver pvalue pequeño
vis_chi4$Valor <- ifelse(vis_chi4$Estimación == "Valor p" & vis_chi4$Valor < 0.001,
                        "< 0.001",
                        round(vis_chi4$Valor, 3))

#para verlo bonito
vis_chi4 %>%
  kable(caption = "Chi cuadrado: Pobreza y Tipo de empleo") %>%
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = FALSE, position = "center") %>%
  column_spec(1, bold = TRUE) %>%
  row_spec(0, bold = TRUE, color = "Black", background = "#D6E8A1")

```
INTERPRETACION: dado que el pvalue es menor a 0.05 = se rechaza H0 = existe asociacion estadísticamente significativa entre la condicion de pobreza y el tipo de empleo por hogar --> la distribucion de la pobreza varia según el tipo de empleo 

tabla porcentajes para grafico bivariado: pobreza y tipo de empleo
```{r}
tabla_porcentaje4= as.data.frame(tabla_contingencia4%>%
  prop.table(1) %>%
  round(3)*100)
tabla_porcentaje4
```
grafico porcentajes bivariado: pobreza e internet
```{r}
graf_bivariado4= ggplot(data=tabla_porcentaje4, aes(x=POBREZA, y=Freq, fill=TIPO_EMPLEO))+
  geom_bar(position="stack", stat="identity")+
  geom_text(aes(label=paste(Freq, "%", sep="")), 
            position = position_stack(), vjust=1, size = 4, color="black", fontface = "bold")+
  labs(x="Pobreza", y="Porcentaje", fill="Tipo de empleo",title="Distribución de los tipos de empleo según condición de pobreza") +
  scale_fill_manual(values=c("Empleo informal"="#D6E8A1", "Empleo formal"="#98B740")) + 
  theme_minimal()+
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
graf_bivariado4
```
===========
ANALISIS MULTIVARIADO

hipotesis anidadas:

H1: La condición de pobreza del hogar puede predecirse a partir del acceso a internet dentro de la misma
```{r}
h1=formula(POBREZA ~ INTERNET)

rlog1=glm(h1,data=enaho,family = binomial)
modelrl=list("ser pobre (I)" = rlog1)

library(modelsummary)
modelsummary(modelrl,
             title = "Regresión Logística",
             stars = TRUE,
             output = "kableExtra")
```

H2: La condición de pobreza del hogar se predice en tanto se considera el acceso a internet del mismo como el nivel educativo alcanzado predominante entre los miembros.

```{r}
h2=formula(POBREZA ~ INTERNET + NIVEL_EDU)

rlog2=glm(h2,data=enaho,family = binomial)
modelrl=list("ser pobre (I)" = rlog1,
             "ser pobre (II)" = rlog2)

library(modelsummary)
modelsummary(modelrl,
             title = "Regresión Logística",
             stars = TRUE,
             output = "kableExtra")
```
AHORA LA MISMA TABLA EXPONENCIADA
```{r}
h2=formula(POBREZA ~ INTERNET + NIVEL_EDU)

rlog2=glm(h2,data=enaho,family = binomial)
modelrl=list("ser pobre (I)" = rlog1,
             "ser pobre (II)" = rlog2)
#FUNCION
formatoNumero = function(x) format(x, digits = 4, scientific = FALSE)

library(modelsummary)
modelsummary(modelrl,
             fmt=formatoNumero,
             exponentiate = T,
             title = "Regresión Logística (Coeficientes Exponenciados)",
             stars = TRUE,
             output = "kableExtra")
```
H3: La condición de pobreza del hogar es condicionada al acceso a internet, al nivel educativo alcanzado predominante entre los miembros y el padecimiento de enfermedades o males crónicos como aspecto prevalente dentro de la unidad doméstica
```{r}
h3=formula(POBREZA ~ INTERNET + NIVEL_EDU + MAL_CRONICO)

rlog3=glm(h3,data=enaho,family = binomial)
modelrl=list("ser pobre (I)" = rlog1,
             "ser pobre (II)" = rlog2,
             "ser pobre (III)" = rlog3)

library(modelsummary)
modelsummary(modelrl,
             title = "Regresión Logística",
             stars = TRUE,
             output = "kableExtra")
```
AHORA LA MISMA TABLA EXPONENCIADA
```{r}
h3=formula(POBREZA ~ INTERNET + NIVEL_EDU + MAL_CRONICO)

rlog3=glm(h3,data=enaho,family = binomial)
modelrl=list("ser pobre (I)" = rlog1,
             "ser pobre (II)" = rlog2,
             "ser pobre (III)" = rlog3)

library(modelsummary)
modelsummary(modelrl,
             fmt=formatoNumero,
             exponentiate = T,
             title = "Regresión Logística (Coeficientes Exponenciados)",
             stars = TRUE,
             output = "kableExtra")
```

H4: La condición de pobreza de la unidad doméstica se puede predecir a partir del acceso a internet, el nivel educativo alcanzado predominante, al padecimiento de enfermedades o males crónicos como condición prevalente y al tipo de empleo más frecuente dentro del hogar 
```{r}
h4=formula(POBREZA ~ INTERNET + NIVEL_EDU + MAL_CRONICO + TIPO_EMPLEO)

rlog4=glm(h4,data=enaho,family = binomial)
modelrl=list("ser pobre (I)" = rlog1,
             "ser pobre (II)" = rlog2,
             "ser pobre (III)" = rlog3,
             "ser pobre (IV)" = rlog4)

library(modelsummary)
modelsummary(modelrl,
             title = "Regresión Logística",
             stars = TRUE,
             output = "kableExtra")
```
AHORA LA MISMA TABLA EXPONENCIADA
```{r}
h4=formula(POBREZA ~ INTERNET + NIVEL_EDU + MAL_CRONICO + NIVEL_EDU)

rlog4=glm(h4,data=enaho,family = binomial)
modelrl=list("ser pobre (I)" = rlog1,
             "ser pobre (II)" = rlog2,
             "ser pobre (III)" = rlog3,
             "ser pobre (IV)" = rlog4)

library(modelsummary)
modelsummary(modelrl,
             fmt=formatoNumero,
             exponentiate = T,
             title = "Regresión Logística (Coeficientes Exponenciados)",
             stars = TRUE,
             output = "kableExtra")
```
mejor modelo
```{r}
library(lmtest)

lrtest(rlog1,rlog2, rlog3,rlog4) %>%
kable(caption = "Tabla LRT para comparar modelos")%>%kableExtra::kable_styling(full_width = FALSE)
```
seleccion de modelo = modelo 4
se procede a evaluar el modelo seleccionado

calcular probabilidad de que un hogar sea pobre
```{r}
enaho$predictedProbs <- predict(rlog4, enaho,type = "response")
head(enaho$predictedProbs, 20)
```
volver a si o no (de 0 y 1 a si y no, para hacer una predicción más útil)

--> umbral de decision (valor de probabilidad que se utiliza para asignar una predicción, es un punto de corte para tomar decisiones) predeterminado = 0.5
  - cuando la probabilidad predicha es mayor o igual que 0.5 el modelo predice si pobreza / cuando la probabilidad predicha es menor que 0.5 se predice no pobreza
  
umbral de decision directamente relacionado con = balance entre sensibilidad (capacidad del modelo para identificar correctamente los casos positivos) y especificidad (capacidad del modelo para identificar correctamente los casos negativos)  
--> un umbral bajo (mayor sensibilidad) es útil para "descartar" la presencia de la condición cuando el resultado es negativo

SEGUN (Trevethan 2017): la mejor manera de determinar el umbral de decision más exacto seria analizando la curva ROC (evaluar el equilibrio entre la sensibilidad y la especificidad, pues el area bajo al curva (AUC) identifica el punto de equilibrio óptimo, es decir el punto de corte mas adecuado)
 
```{r}
library(pROC)
roc_curva <- roc(enaho$pobreza, enaho$predictedProbs)
plot(roc_curva, main = "Curva ROC", col = "darkred", lwd = 2)
auc(roc_curva)

#para encontrar el umbral optimo
coords(roc_curva, "best", ret = "threshold")
```
interpretacion: segun la curva ROC, el umbral de decision optimo sería 0.23 aprox. pues este es el mejor balance entre sensibilidad y especificidad = se entiende que si la probabilidad predicha es mayor que este umbral, la observacion (hogar) será clasificado como "pobre" si es menor se le clasificara como "no pobre"

AHORA BIEN: tomando en cuenta los costos sociales y politicos que implica decidir entre priorizar la sensibilidad o la especificidad: SOLO EXPLICAR PORQUE NO SE PUSO UMBRAL DE 0.5 Y POR QUE SE ESCOGIÓ EL UMBRAL DE 0.3 PORQUE SINO DAS MUCHAS VUELTAS  

se aplicó la prueba Kappa primero tomando en cuenta el umbral predeterminado (0.5) = se creó un sesgo a falsos negativos 
--> la interpretacion de los falsos negativos puede afectar la creacion de politicas publicas pues afecta la interpretacion de datos, por ejemplo en la asignacion de recursos para combatir la pobreza - en este caso, el sesgo de falsos negativos implica que no se identifican a todas las personas pobres

tomando en cuenta que un umbral de 0.2 como indica resultado de curva ROC = se generan más falsos positivos = hogares no pobres podrían recibir recursos destinados a los hogares que realmente son pobres = los recursos no llegan a quienes lo necesitan 
--> el valor de kappa al umbral 0.2 y se obtuvo un resultado de 0.2655 = NO poner lo de KAPPA, solo poner kappa del escogido porque igual el kappa es bajo y debería ser cercano a 1

tomando en cuenta un umbral de 0.4 = también se reducen mucho más los falsos positivos por que se prioriza la sensibilidad, sin embargo afectaría a la cantidad de hogares no pobres, en tal sentido se corre el riesgo de que hogares pobres sean considerados no pobresm, un tanto similar a lo que ocurría con el umbral predeterminado. 
--> el valor de kappa al umbral 0.4 fue de 0.2633

tomando en cuenta un umbral de 0.3 = se reducen falsos positivos = se evita que hogares no pobres sean clasificados erroneamente como pobres = se optimizan recursos (se evitan problemas en la asignacion de recursos como ocurrió en la pandemia)
--> el valor de Kappa al umbral de 0.3 es de 0.2985 = valor mayor sobre la prueba Kappa, esto quiere decir que es ligeramente más acertado que al usar los otros

0.3 porque el punto medio entre 0.5(sesgo a falsos negativos) y 0.23(equilibrio entre sensibilidad y especificidad, resultado de curva ROC) es 0.365, sin embargo considerando que se requiere de priorizar la sensibilidad teniendo como antecedentes los problemas que se identificaron con la distribucion de recursos en tiempos de pandemia se entiende que se debe reducir el sesgo de falsos positivos, así se prioriza un valor de umbral de decision menor

--> se considera el 0.3 pues partiendo del analisis de la contraloria (2020) sobre los hogares en situacion de pobreza que fueron excluidos del padron de hogares beneficiaros, se identifica que la cantidad de hogares en situacion de pobreza que fueron excluidos fue considerablemnente mayor a la cantidad de hogares que  se incluyó en este padrón y no les correspondía recibir el beneficio. Por tanto, a fin de evitar este sesgo, se considera necesario priorizar más la sensibilidad a fin de reducir la cantidad de hogares como falsos negativos. 
--> Tomando en cuenta el analisis de la contraloria también se indentificó que 238 hogares estuvieron incluidos en el padrón de beneficiaros pese a que no deberían ser considerados pobres, ya que sus miembros percibieron entre octubre 2019 y febrero del 2020 ingresos per capita que superaban el umbral de pobreza establecido por la metodología OIT (corregir nombre de metogología) -info de la tesis de maestria up pp 35-. En línea del presente estudio y su enfoque multidimensional de pobreza, se recomienda que la determinacion de pobreza de un hogar no debe regirse unicamente considerando su capacidad de superar o no el umbral de pobreza entendido en terminos monetarios o capacidad adquisitiva, puesto que la pobreza implica cuestiones mucho más subjetivas que engloba el desarrollo de los sujetos miembros del hogar. 



Desarrollar problema que implicaría sobreestimar la cantidad de hogares pobres: 


ha generado desaciertos y retraso para concretizar el cobro del subsidio en muchas familias, cuando la finalidad del bono era brindar una asistencia oportuna a los hogares más vulnerables frente a esta pandemia --> midis 2020

Asimismo, el MIDIS (2020) indicó respecto al diseño del sistema de focalización, que observa la falta de un balance entre el error de inclusión (incluir a una persona que no califica) y el error de
exclusión (excluir a una persona que si califica), precisando que se le da demasiada importancia a minimizar el error de inclusión, debido al temor al fraude y la filtración, lo cual ha generado
falta de transparencia en la información que se proporciona a los usuarios. Sumado a lo anterior, el MIDIS afirma que no se ha logrado aún implementar medidas que se enfoquen en la reducción del error de exclusión tales como campañas de búsqueda de solicitantes. --> up tesis maestria


 
```{r}
enaho$predicted = ifelse(enaho$predictedProbs > 0.365, "yes","no")
```
"yes" si la probabilidad es mayor que 0.3 y "no" si es 0.3 o menos


1= Pobreza 
0= No pobreza
```{r}
enaho$pobreza=enaho$POBREZA

enaho$pobreza <- recode(enaho$pobreza,
                        "1" = "yes",
                        "0" = "no")
```
ver columnas
```{r}
head(enaho[,c("predicted","pobreza")],10)
```
---> SE ENTIENDE: que en estas 10 filas se predice correctamente, pues el modelo predice no y la respuesta en la data es no (no=0) -la columnas predicte busca ser la misma que POBREZA-

matriz de confunsion: para saber que tanto acertó el modelo

```{r}
library(cvms)
ConfMatrix=confusion_matrix(predictions =  enaho$predicted,
                      targets= enaho$pobreza)
```
sensibilidad = capaciodad del modelo para identificar correctamente los casos postivos (es decir identificar correctamente los hogares pobres) --> cuantos casosspositivos (pobreza) fueron correctamente identificados por el modelo (si se prioriza sensibilidad se reduce el numero de falsos negativos y se maximiza la cantidad de positivos) --> esto escogí 

Especificidad = capacidad del modelo para identificar correctamente los casos negativos (es decir identificar correctamente los hogares NO pobres) --> cuantos casos negativos (no pobreza) fueron correctamente identificados por el modelo (si se pripriza la especificidad y se reducen los falsos positivos)

sensibilidad
```{r}
ConfMatrix$Sensitivity
```
especificidad
```{r}
ConfMatrix$Specificity
```

```{r}
ConfMatrix$Kappa
```
con umbral de 0.5 = kappa en 0
con umbral en 0.4 = kappa en 0.2633
con umbral en 0.3 = kappa en 0.2985
con umbral en 0.2 = kappa en 0.2655

indice de kappa = el índice Kappa te ayuda a saber qué tan bien está haciendo tu modelo estas predicciones
  - Un valor de Kappa cercano a 1 significa que hay un acuerdo perfecto entre lo que predice el modelo y lo que es realmente cierto = el modelo está funcionando

  - Un valor de Kappa cercano a 0 significa que el acuerdo es lo que esperarías si el modelo estuviera adivinando al azar, sin ningún poder predictivo real. En otras palabras, el modelo no está ayudando mucho, predice similar que si estuviera adivinando al azar

  - Un valor negativo sugiere que el modelo está prediciendo peor que el azar, lo que sería un signo claro de que algo no está funcionando correctamente.

```{r}
library(cvms)
plot_confusion_matrix(ConfMatrix,
                      class_order=c("yes","no"))
```
interpretacion: 
- 64.7% de las veces el modelo predice correctamente que no hay pobreza, y de esos = 22 123 casos fueron clasificados correctamente como "no pobreza"
- el modelo cometió un error aquí = El 10% de las veces, el modelo predice que no hay pobreza, pero en realidad sí la hay = 3435 casos incorrectamente clasificados.

EFECTOS MARGINALES
```{r}
head(enaho[,c("pobreza","predicted","predictedProbs")])
```

```{r}
library(margins)
margins(rlog4)
```

```{r}
marginalsData=summary(margins(rlog3))
marginalsData%>% kable(caption = "Efectos Marginales Promedio (AME)- Modelo III") %>%kableExtra::kable_styling(full_width = T)
```

==========
ANALISIS FACTORIAL
```{r}
enaho_cluster=as.data.frame(enaho)

enaho_cluster=enaho_cluster[,c("pobreza","INTERNET","MAL_CRONICO","NIVEL_EDU","TIPO_EMPLEO")]

dontselect=c("pobreza")
select=setdiff(names(enaho_cluster),dontselect) 
theData=enaho_cluster[,select]

library(magrittr)
head(theData,10)%>%
    rmarkdown::paged_table()
```
correlacion
```{r}
library(polycor)
corMatrix=polycor::hetcor(theData)$correlations
corMatrix
```
redondear matriz de correlacion a 2 decimales
```{r}
round(corMatrix,2)
```
grafico de matriz de correlacion
```{r}
library(ggcorrplot)
ggcorrplot(corMatrix)
```
test de kaiser-meyer-olkin (KMO)
--> evalúa si los datos son adecuados para aplicar análisis factorial (ayuda a saber las columnas se parecen lso suficiente como para que tenga sentido buscar algo en comun detras de todos ellos 
--> es decir TEST responde a: ¿Las columnas tienen correlaciones suficientes como para justificar un análisis factorial?
```{r}
library(psych)
psych::KMO(corMatrix)
```
verificar si matriz de correlaciones es adecuada
PRUEBA DE MATRIZ DE IDENTIDAD
--> la matriz de identidad es una matriz de estructura cuadrada donde todos los valores en la diagonal son 1 
--> TEST DE BARTLETT: evalua si la matriz de correlaciones es significativamente diferente de una identidad -compara mi matriz de correlaciones con la matriz de identidad, para verificar existen diferencias estadisticamente significativas- 

TEST DE BARLETT
H0=La matriz de correlaciones es una matriz identidad (no hay correlaciones significativas)
H1=Hay correlaciones significativas entre las variables 
--> se debe RECHAZAR LA H0 (debe aparecer FALSE), para afirmar que existen correlaciones suficientes entre las variables y el analisis factorial es adecuado 
```{r}
cortest.bartlett(corMatrix,n=nrow(theData))$p.value>0.05
```
--> Se rechaza la hipotesis nula (sale FALSE) = se afirma que existen correlaciones suficientes entre la svariables --> el analisis factorial es adecuado porque la estructura de correlaciones si justifica extraer factores

PRUEBA DE MATRIZ SINGULAR= siempre falso (no hay matriz de singular y se puede continuar con analisis) 

-->si es una matriz singular, no se puede continuar con el analisis factorial porque las variables estan REDUNDANDO TOTALMENTE ENTRE SI (llamado: colinealidad perfecta: A , B, C = A+B) --> por tanto la matriz de correlaciones se vuelve inutilizable = no se puede determinar cuántos factores son válidos a causa de la pérdida de independencia
```{r}
library(matrixcalc)
is.singular.matrix(corMatrix)
```
-> FALSE = se anula la hipotesis nula de que la matriz de correlacion es una matriz singular = ES DECIR LA MATRIZ DE CORRELACION NO ES UNA MATRIZ SINGULAR Y SE PUEDE CONTINUAR CON ANALISIS FACTORIAL 

```{r}
sapply(theData, class)
```


cantidad de factores recomendados


==========
ANALISIS CONGLOMERADO
```{r}
library(BBmisc)
enaho[,c(2:5)]=normalize(enaho[,c(2:5)],method='standardize')
```
correlacion





